{"version":3,"file":"background.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./attacks/attack_hook.ts","webpack:///./attacks/attack_hook_none.ts","webpack:///./background.ts"],"sourcesContent":["export class AttackHook {\n    onNetwork(details) {\n        return { cancel: false };\n    }\n    async onCredentialCreate(msg, sender) {\n        throw new Error('onCredentialCreate not implemented');\n    }\n    async onCredentialGet(msg, sender) {\n        throw new Error('onCredentialGet not implemented');\n    }\n    getName() {\n        throw new Error('getName not implemented');\n    }\n}\n","import { AttackHook } from './attack_hook';\nexport class AttackHookNone extends AttackHook {\n    getName() {\n        return 'attack-none';\n    }\n    async onCredentialCreate(msg, sender) {\n        return {\n            type: 'create_response',\n            requestID: msg.requestID,\n            credential: msg.originalCredential,\n        };\n    }\n    async onCredentialGet(msg, sender) {\n        return {\n            type: 'sign_response',\n            requestID: msg.requestID,\n            credential: msg.originalCredential,\n        };\n    }\n}\n","// Initialize counter when extension is installed\n// chrome.runtime.onInstalled.addListener(() => {\n//     chrome.storage.local.set({ callCount: 0 });\n//     console.log('[Background] Extension installed');\n// });\nimport { AttackHookNone } from './attacks/attack_hook_none';\n// import { AttackHookMisBinding } from './attacks/attack_hook_mis_binding';\n// import { getLogger } from './logging.js';\n// const log = getLogger('background');\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('Extension installed');\n});\n// Needs to be stored in local\nlet attackType = null; // Initialize as null\n/**\n * Listens for web requests before they are sent and handles specific authentication flows\n * based on the current attack type.\n *\n * This listener specifically handles:\n * 1. Sync Login Attack Flow:\n *    - Monitors requests to testbank.com authentication endpoint\n *    - When detected, triggers original login flow via content script message\n *    - Also monitors GitHub 2FA WebAuthn requests\n *    - When GitHub 2FA detected, injects iframe code via content script\n *\n * The listener works in conjunction with the AttackHook implementations to:\n * - Intercept and potentially modify web requests\n * - Coordinate with content scripts for DOM manipulation\n * - Handle different authentication flows based on attack type\n *\n * @param {Object} details - Web request details object containing:\n *   - url: The URL of the request\n *   - requestBody: The request body if present\n *   - other standard WebRequest properties\n * @returns {Object|undefined} - Returns attack type specific network modifications\n *                              or undefined to allow request unmodified\n */\n// chrome.webRequest.onBeforeRequest.addListener((details) => {\n//     // Get attack type here from local storage\n//     chrome.storage.local.get(['attackType'], (result) => {\n//         attackType = result.attackType;\n//     });\n//     // Generate new attack hook based on attack type\n//     if (attackType == \"attack-sync-login\") {\n//         console.log(details.url);\n//         if (details.url === \"https://testbank.com:8443/api/v1/authenticate/finish\") {\n//             console.log(\"Request sent to the specified URL:\", details.url);\n//             chrome.tabs.query({ active: true, currentWindow: true }, function(tabs) {\n//               // Retrieve the active tab\n//               var activeTab = tabs[0];\n//               // Send a message to the content script\n//               chrome.tabs.sendMessage(activeTab.id, { message: \"start-orig-login\" });\n//             });\n//         } else if (details.url === \"https://github.com/sessions/two-factor/webauthn\") {\n//                     chrome.tabs.query({ active: true, currentWindow: true }, function(tabs) {\n//               // Retrieve the active tab\n//               var activeTab = tabs[0];\n//               console.log(\"Detected 2FAA URL\");\n//               // Send a message to the content script\n//               chrome.tabs.sendMessage(activeTab.id, { message: \"push-iframe-code\" });\n//             });\n//         }\n//     }\n//     return attackType.onNetwork(details);\n// }, { urls: ['<all_urls>'] }, ['blocking', 'requestBody']);\n// chrome.webRequest.onHeadersReceived.addListener(\n//     function(info) {\n//         var headers = info.responseHeaders;\n//         for (var i=headers.length-1; i>=0; --i) {\n//             var header = headers[i].name.toLowerCase();\n//             if (header == 'x-frame-options' || header == 'frame-options') {\n//                 headers.splice(i, 1); // Remove header\n//             }\n//         }\n//         headers.push({ name: 'Permissions-Policy', value: 'publickey-credentials-get=*' });\n//         return {responseHeaders: headers};\n//     }, {\n//         urls: [\n//             '*://*/*', // Pattern to match all http(s) pages\n//             // '*://*.example.org/*', // Pattern to match one http(s) site\n//         ], \n//         types: [ 'sub_frame' ]\n//     }, [\n//         'blocking',\n//         'responseHeaders',\n//         // Modern Chrome needs 'extraHeaders' to see and change this header,\n//         // so the following code evaluates to 'extraHeaders' only in modern Chrome.\n//         // chrome.webRequest.OnHeadersReceivedOptions.EXTRA_HEADERS,\n//     ].filter(Boolean)\n// );\n/**\n * Handles WebAuthn credential creation requests from content scripts.\n * This function is called whenever navigator.credentials.create() is invoked.\n * It delegates the credential creation to the currently active attack hook.\n *\n * @param {WebAuthnRequestMessage} msg - The WebAuthn request message containing credential creation parameters\n * @param {chrome.runtime.MessageSender} sender - Information about the sender of the message, including tab info\n * @returns {Promise<WebAuthnResponseMessage|WebAuthnErrorMessage|undefined>} A promise that resolves to:\n *   - WebAuthnResponseMessage on successful credential creation\n *   - WebAuthnErrorMessage if an error occurs during creation\n *   - undefined if the sender tab is invalid\n */\nconst create = async (msg, sender) => {\n    console.log('In create');\n    if (!sender.tab || !sender.tab.id) {\n        console.log('received create event without a tab ID');\n        return;\n    }\n    if (!attackType) {\n        await getAttackType();\n    }\n    return await attackType.onCredentialCreate(msg, sender);\n};\n/**\n * Handles WebAuthn credential retrieval/signing requests from content scripts.\n * This function is called whenever navigator.credentials.get() is invoked.\n * It delegates the credential retrieval to the currently active attack hook.\n *\n * @param {WebAuthnRequestMessage} msg - The WebAuthn request message containing credential retrieval parameters\n * @param {chrome.runtime.MessageSender} sender - Information about the sender of the message, including tab info\n * @returns {Promise<WebAuthnResponseMessage|WebAuthnErrorMessage|undefined>} A promise that resolves to:\n *   - WebAuthnResponseMessage on successful credential retrieval/signing\n *   - WebAuthnErrorMessage if an error occurs during retrieval\n *   - undefined if the sender tab is invalid\n */\nconst sign = async (msg, sender) => {\n    // if (!sender.tab || !sender.tab.id) {\n    //     console.log('received sign event without a tab ID');\n    //     return;\n    // }\n    // if (!attackType) {\n    //     await getAttackType();\n    // }\n    // return await attackType!.onCredentialGet(msg, sender);    \n};\nfunction convertAttackToHook(attackName) {\n    switch (attackName) {\n        case 'attack-mis-binding':\n            attackType = new AttackHookNone();\n            break;\n        case 'attack-double-binding1':\n            attackType = new AttackHookNone();\n            break;\n        case 'attack-double-binding2':\n            attackType = new AttackHookNone();\n            break;\n        case 'attack-clone-detection':\n            attackType = new AttackHookNone();\n            break;\n        case 'attack-sync-login':\n            attackType = new AttackHookNone();\n            break;\n        default:\n            attackType = new AttackHookNone();\n            break;\n    }\n}\nasync function setAttackImpl(attackName) {\n    convertAttackToHook(attackName);\n    // Save to local storage\n    await setAttackTypeInStorage(attackName);\n    // This may change passToOrig depending on attack type. Send message to the back if needed\n    await sendPassToOrigValue();\n}\nasync function sendPassToOrigValue() {\n    // let passToOrig = true;\n    // if (!attackType) {\n    //     await getAttackType();\n    // }\n    // console.log(\"SEND FUNCT\", attackType!.getName());\n    // if (attackType!.getName() === 'attack-double-binding2') {\n    //     passToOrig = false;\n    //     console.log(\"INFAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLSSSSSSSSSSSSEEEEEEEE\");\n    // }\n    // console.log(\"value of passToOrig passed from back\", passToOrig)\n    // chrome.tabs.query({ active: true, currentWindow: true }, function(tabs) {\n    //     var activeTab = tabs[0];\n    //     if (activeTab.id) {\n    //         chrome.tabs.sendMessage(activeTab.id, { message: 'passToOrig', val: passToOrig});\n    //     } else {\n    //         console.log(\"BROKEN FUNCTIONALITY\")\n    //     }\n    // });\n}\n// Initialize attack type when service worker starts. Put in on message receive, because I know the service will start up then if it is idle, but there might be a better way.\nasync function refreshAttackType() {\n    if (attackType) {\n        console.log(\"No need to refresh attack type\");\n        return;\n    }\n    console.log(\"Refreshing attack type\");\n    const result = await chrome.storage.local.get(['attackType']);\n    console.log(\"Result from local storage:\", result.attackType);\n    if (result.attackType) {\n        console.log(\"Creating new AttackHook\", result.attackType);\n        convertAttackToHook(result.attackType);\n    }\n    else {\n        // Default to none if nothing in storage\n        console.log(\"Creating new AttackHookNone\");\n        attackType = new AttackHookNone();\n        await chrome.storage.local.set({ attackType: 'none' });\n    }\n    console.log(\"New attack type refreshed:\", attackType);\n}\nasync function getAttackType() {\n    if (attackType) {\n        return attackType;\n    }\n    else {\n        await refreshAttackType();\n        return attackType;\n    }\n}\nasync function setAttackTypeInStorage(attackName) {\n    console.log(\"Setting...\", attackName);\n    await chrome.storage.local.set({ attackType: attackName });\n}\nchrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {\n    console.log('Received form data:', msg);\n    // Create a response handler that ensures proper async flow\n    const handleMessage = async () => {\n        try {\n            await refreshAttackType();\n            console.log('Attack type after refresh:', attackType);\n            switch (msg.type) {\n                case 'attack-type-change':\n                    await setAttackImpl(msg.newAttackType);\n                    console.log(\"Attack type changed:\", attackType);\n                    break;\n                case 'attack-type-get':\n                    const currentType = await getAttackType();\n                    console.log(\"Attack type in switch:\", currentType);\n                    sendResponse({\n                        type: 'attack-type-get-response',\n                        attackType: currentType.getName()\n                    });\n                    break;\n                case 'create':\n                    const createResponse = await create(msg, sender);\n                    sendResponse(createResponse);\n                    break;\n                case 'sign':\n                    const signResponse = await sign(msg, sender);\n                    sendResponse(signResponse);\n                    break;\n                case 'getPassToOrig':\n                    await sendPassToOrigValue();\n                    break;\n                default:\n                    sendResponse(null);\n            }\n        }\n        catch (error) {\n            console.error('Error handling message:', error);\n            sendResponse({ error: error.message });\n        }\n    };\n    // Start the async handling\n    handleMessage();\n    // Return true to indicate we'll call sendResponse asynchronously\n    return true;\n});\n"],"names":[],"sourceRoot":""}